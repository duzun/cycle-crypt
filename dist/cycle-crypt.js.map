{"version":3,"file":"cycle-crypt.js","sources":["../node_modules/string-encode/string-encode.js","../lib/randomBytes.js","../CycleCrypt.js","../cycle-crypt.js"],"sourcesContent":["/**\n * Convert different types of JavaScript String to/from Uint8Array.\n *\n * @author Dumitru Uzun (DUzun.Me)\n * @version 0.2.2\n */\n\n/*requires Uint8Array*/\n/*globals escape, unescape, encodeURI, decodeURIComponent, btoa*/\n\nexport const chr = String.fromCharCode;\n\nexport function ord(chr) {\n    return chr.charCodeAt(0);\n}\n\nexport function buffer2bin(buf) {\n    buf = view8(buf);\n    return chr.apply(String, buf);\n}\n\n/**\n * Get the hex representation of a buffer (TypedArray)\n *\n * @requires String.prototype.padStart()\n *\n * @param   {TypedArray}  buf Uint8Array is desirable, cause it is consistent regardless of the endianness\n *\n * @return  {String} The hex representation of the buf\n */\nexport function buffer2hex(buf) {\n    const bpe = buf.BYTES_PER_ELEMENT << 1;\n    return buf.reduce((r, c) => r += (c >>> 0).toString(16).padStart(bpe,'0'), '');\n}\n\nexport function buffer2str(buf, asUtf8) {\n    if(typeof buf == 'string') return buf;\n    buf = buffer2bin(buf);\n    if (asUtf8 !== false && !isASCII(buf)) {\n        if(asUtf8) {\n            buf = utf8Decode(buf);\n        } else if(asUtf8 == undefined) {\n            try {\n                buf = utf8Decode(buf);\n            } catch(err) {}\n        }\n    }\n    return buf;\n}\n\nexport function str2buffer(str, asUtf8) {\n    str = String(str);\n    if(asUtf8 == undefined) {\n        // Some guessing\n        asUtf8 = hasMultibyte(str); // || !isASCII(str)\n    }\n    if (asUtf8) {\n        str = utf8Encode(str);\n    }\n\n    // Smaller x2\n    // return new Uint8Array(String(str).split('').map(ord));\n\n    // Faster x3-4\n    let len = str.length;\n    const buf = new Uint8Array(len);\n    while(len--) buf[len] = str.charCodeAt(len);\n    return buf;\n}\n\nconst nonHexDigitRE = /[^0-9a-f]/g;\n\n/**\n * Read a hex string into a buffer (Uint8Array), ignoring non-hex chars.\n *\n * @param   {String}  str\n *\n * @return  {Uint8Array}\n */\nexport function hex2buffer(str) {\n    str = str.replace(nonHexDigitRE, '');\n    const len = str.length;\n    const ret = new Uint8Array((len + 1) >>> 1);\n\n    for(let i=0; i<len; i+=2) {\n        ret[i >>> 1] = parseInt(str.slice(i, i+2), 16);\n    }\n\n    return ret;\n}\n\n/**\n * This method is a replacement of Buffer.toString(enc)\n * for Browser, where Buffer is not available.\n *\n * @requires btoa\n *\n * @this {Uint8Array}\n *\n * @param   {String}  enc  'binary' | 'hex' | 'base64' | 'utf8' | undefined\n *\n * @return  {String}\n */\nexport function toString(enc) {\n    // The Node.js equivalent would be something like:\n    // if(typeof Buffer == 'function') {\n    //     if(enc === false) enc = 'binary';\n    //     if(enc === true) enc = 'utf8';\n    //     return Buffer.from(this.buffer, this.byteOffset, this.byteLength).toString(enc);\n    // }\n    switch(enc) {\n        case false:\n        case 'binary': return buffer2bin(this);\n        case 'hex': return buffer2hex(this);\n        case 'base64': return btoa(buffer2bin(this));\n        case 'utf8': enc = true; break;\n    }\n    return buffer2str(this, enc);\n}\n\nexport function view8(buf, start, len) {\n    // If buf is a Buffer, we still want to make it an Uint8Array\n    if(!start && !len && buf instanceof Uint8Array && !buf.copy) return buf;\n    start = start >>> 0;\n    if(len == undefined) len = buf.byteLength - start;\n    return new Uint8Array(buf.buffer, buf.byteOffset+start, len);\n}\n\nlet _isLittleEndian;\nexport function isLittleEndian() {\n    if(_isLittleEndian !== undefined) return _isLittleEndian;\n    _isLittleEndian = !!(new Uint8Array(new Uint16Array([1]).buffer)[0]);\n    isLittleEndian = () => _isLittleEndian;\n    return _isLittleEndian;\n}\n\nexport function switchEndianness32(i) {\n    return (i&0xFF)<<24\n        | (i&0xFF00)<<8\n        | i>>8&0xFF00\n        | i>>24&0xFF\n    ;\n}\n\nexport function guessEncoding(str) {\n    if(hasMultibyte(str)) return 'mb';\n\n    // @todo: test which is faster, utf8bytes() or RegExp\n    if(isHEX(str)) return 'hex';\n    // if(isASCII(str)) return 'ascii';\n    // if(isUTF8(str)) return 'utf8';\n\n    let mbLen = utf8bytes(str);\n    if(mbLen) return 'utf8';\n    if(mbLen === 0) return 'ascii';\n    if(mbLen === false) {\n        mbLen = utf8bytes(str, true);\n        if(mbLen) return '~utf8'; // UTF8, but with async characters at the edges\n    }\n    return 'binary';\n}\n\nconst hasMultibyteRE = /([^\\x00-\\xFF])/;\nconst isHEXRE = /^[0-9a-f\\s]*$/i;\nconst isASCIIRE = /^[\\x00-\\x7F]*$/;\nconst isUTF8RE = /^(?:[\\x00-\\x7F]|[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF][\\x80-\\xBF]|[\\xF0-\\xF7][\\x80-\\xBF][\\x80-\\xBF][\\x80-\\xBF])*$/;\n\nexport function hasMultibyte(str) {\n    let m = hasMultibyteRE.exec(str);\n    return m ? m[1] : false;\n}\n\nexport function isBinary(str) {\n    return !hasMultibyte(str);\n}\n\nexport function isASCII(str) {\n    return isASCIIRE.test(str);\n}\n\nexport function isUTF8(str) {\n    return isUTF8RE.test(str);\n}\n\nexport function isHEX(str) {\n    return isHEXRE.test(str);\n}\n\nexport function utf8bytes(str, allowAsyncChars) {\n    var l = str.length\n    ,   i = 0\n    ,   u = 0\n    ,   c\n    ,   a = -1\n    ,   asy = +!!allowAsyncChars\n    ;\n\n    for( ; i < l ; ) {\n        c = str.charCodeAt(i++);\n        if( c < 0x80 ) continue; // ASCII\n        if( 0xFF <= c ) return false; // has multi-byte\n\n        // async UTF8 character\n        if( (c & 0xC0) == 0x80 ) {\n            // Ignore async UTF8 characters at the beginning\n            if(asy == i) {\n                ++u;\n                ++asy;\n                continue;\n            }\n            return false;\n        }\n\n        // Check sync UTF8 bytes\n        a   = (c & 0xE0) !== 0xC0\n            ? (c & 0xF0) !== 0xE0\n            ? (c & 0xF8) !== 0xF0\n            ? false\n            : 3\n            : 2\n            : 1\n        ;\n        if(!a) return false; // Not an ASCII, nor sync UTF8 bytes\n\n        for( ; (u += 1) && a-- && i < l; ) {\n            c = str.charCodeAt(i++);\n            if((c & 0xC0) !== 0x80) {\n                return false; // Not an ASCII, nor sync UTF8 bytes\n            }\n        }\n    }\n\n    // Ignore async UTF8 characters at the end\n    if(~a && !allowAsyncChars) return false;\n\n    return u;\n}\n\nexport function utf8Encode(str) {\n    return unescape(encodeURI(str));\n}\n\nexport function utf8Decode(str) {\n    return decodeURIComponent(escape(str));\n}\n","/*requires Uint8Array, Uint32Array*/\n\nimport { toString } from 'string-encode';\n\nexport default function randomBytes(size) {\n    const bits = -1 >>> 0;\n\n    let len = size & 3;\n    len = len ? size + 4 - len : size;\n    let ret = new Uint8Array(len);\n    const words = new Uint32Array(ret.buffer);\n    let ent = Date.now();\n\n    len >>= 2;\n    while (len--) {\n        words[len] =\n        ent ^= Math.random() * bits;\n    }\n\n    if(ret.length > size) {\n        ret = ret.slice(0, size);\n    }\n\n    ret.toString = toString;\n    return ret;\n}\n","/*requires Uint8Array, Uint32Array*/\n\nimport randomBytes from './lib/randomBytes';\nimport { str2buffer, view8, toString } from 'string-encode';\n\n/**\n * Variable size symmetric key encryption algorithm.\n * The cipher-key is generated by cycling the input key with a variation of XorShift+ PRNG.\n * The bigger the key-size, the longer the period.\n *\n * @param   {String|ArrayBuffer}  key   The encryption key\n * @param   {String|ArrayBuffer|Boolean} salt\n *              If a string, use it as salt.\n *              If TRUE, generate salt.\n * @param {Number} saltRounds - Number of rounds of initial state generated from salt âŠ• key\n */\nexport default function CycleCrypt(key, salt, saltRounds) {\n    const self = this;\n\n    key = str2buf(key);\n    if (salt === true || salt === undefined) {\n        salt = randomBytes(Math.min(256, key.byteLength << 1));\n    }\n    self.salt = salt;\n    self._key = key = saltKey(key, str2buf(salt), saltRounds);\n}\n\nObject.defineProperties(CycleCrypt.prototype, {\n    constructor: {\n        value: CycleCrypt,\n    },\n\n    /**\n     * Encrypt/decrypt the data and advance the internal state of the cipher-key.\n     *\n     * @param   {String|ArrayBuffer}  data  Data to encrypt\n     *\n     * @return  Uint8Array The encrypted/decrypted data\n     */\n    _: {\n        value: function _(data) {\n            data = str2buf(data);\n            const { dataLength } = data;\n            if (!dataLength) return data;\n\n            const key = this._key;\n            let klen = key.length;\n            let len = data.length;\n            for (let i = 0, k = 0; i < len; ++i, ++k === klen && (k = 0)) {\n                if (!k) mixKey(key);\n                data[i] ^= key[k];\n            }\n\n            data = view8(data, 0, dataLength);\n            data.toString = toString;\n            return data;\n        }\n    },\n\n    /**\n     * Get the number of bytes in the key\n     *\n     * @return  int\n     */\n    keyByteSize: {\n        get() {\n            return this._key.byteLength;\n        }\n    }\n});\n\n// Static methods:\nCycleCrypt.randomBytes = randomBytes; // Uint8Array\nCycleCrypt.toString = toString;\nCycleCrypt.str2buffer = str2buffer; // Uint8Array\nCycleCrypt.str2buf = str2buf; // Uint32Array\n// // CycleCrypt.buf2str = buf2str;\n\n/**\n * Use a variation of Xorshift+ to mix the key\n *\n * @param   Uint32Array $key List of int32 values representing the key\n * @param   int   $rounds Number of rounds to process the key\n *\n * @return  array A mixed key\n */\nfunction mixKey(key, rounds) {\n    let len = key.length;\n    let k = len > 1 ? key[len - 1] : 0;\n\n    if (rounds == undefined) rounds = 1;\n    while (rounds-- > 0) {\n        for (let $i = len; $i--;) {\n            let ki = $i % len;\n            k = key[ki] + k;\n            k ^= k << 13; // 19\n            k ^= k >>> 17; // 15\n            k ^= k << 5; // 27\n            // k >>>= 0;\n            key[ki] = k;\n        }\n    }\n\n    return key;\n}\n\n/**\n * Use a variation of Xorshift+ to salt the key\n *\n * @param   Uint32Array $key\n * @param   Uint32Array $salt\n * @param   int   $rounds Number of rounds to mix the key\n *\n * @return  array A mixed key\n */\nfunction saltKey(key, salt, rounds) {\n    let klen = key.length;\n    let slen = salt.length;\n    if (!slen) return key;\n\n    // make a copy to avoid altering the input salt\n    salt = salt.slice();\n\n    let k = klen > 1 ? key[klen - 1] : 0;\n    let s = slen > 1 ? salt[slen - 1] : 0;\n\n    if (rounds == undefined) rounds = 1;\n    while (rounds-- > 0) {\n        for (let i = Math.max(klen, slen); i--;) {\n            let ki = i % klen;\n            let si = i % slen;\n            k = key[ki] + k;\n            s = salt[si] + s;\n\n            s ^= s << 13; // 19\n            s ^= s >>> 7; // 25\n\n            k ^= k << 11; // 21\n            k ^= k >>> 8; // 24\n\n            // s >>>= 0;\n            k += s;\n            // k >>>= 0;\n\n            key[ki] = k;\n            salt[si] = s;\n        }\n    }\n\n    return key;\n}\n\nfunction str2buf(str) {\n    if (!str || typeof str.byteLength != 'number') {\n        str = str2buffer(str);\n    }\n    else {\n        str = view8(str);\n    }\n\n    // Make sure the new buffer has a multiple of 4 byteLength\n    const { byteLength } = str;\n    let b = byteLength & 3;\n    let i;\n    // if(b) {\n        b = byteLength + (b && (4 - b));\n        i = new Uint8Array(b);\n        i.set(str);\n    // }\n    // else {\n    //     b = byteLength;\n    //     i = str.slice();\n    // }\n\n    str = new Uint32Array(i.buffer, i.byteOffset, b >> 2);\n    str.dataLength = byteLength;\n\n    return str;\n}\n\n// Unused\n// function buf2str(buf) {\n//     return buffer2str(view8(buf));\n// }\n","// ---------------------------------------------------------------\n/*requires Uint8Array, Uint32Array*/\n// ---------------------------------------------------------------\nimport CycleCrypt from './CycleCrypt';\nimport { str2buffer, view8 } from 'string-encode';\n\ncycleCrypt.CycleCrypt = CycleCrypt;\ncycleCrypt.randomBytes = CycleCrypt.randomBytes;\ncycleCrypt.str2buffer = CycleCrypt.str2buffer;\n\n// ---------------------------------------------------------------\n/**\n * Simple encryption using xor, a key and salt.\n *\n * @param   {String|Uint8Array}  $key   The encryption key\n * @param   {String|Uint8Array}  $data  Data to encrypt\n * @param   {String|Uint8Array|bool} $salt\n *              If a string, use it as salt.\n *              If TRUE, generate salt and prepend it to the encrypted data.\n *              If FALSE, get the salt from the data.\n * @param {Number} saltRounds - Number of rounds of initial state generated from salt âŠ• key\n *\n *\n * @return  Uint8Array  The encrypted data. If $salt is TRUE, the generated salt is prepended to the result.\n */\nexport default function cycleCrypt(key, data, salt = true, saltRounds=1) {\n\n    // Read salt from input\n    if (salt === false) {\n        data = view8(typeof data == 'string' ? str2buffer(data) : data);\n        let i = data[0];\n        salt = data.slice(1, ++i);\n        data = data.slice(i);\n    }\n    else if (salt === undefined) {\n        salt = true;\n    }\n\n    const cc = new CycleCrypt(key, salt, saltRounds);\n    data = cc._(data);\n\n    // Add the generated salt to the output\n    if (salt === true) {\n        salt = cc.salt;\n        let ret = new Uint8Array(1 + salt.byteLength + data.byteLength);\n        ret[0] = salt.byteLength;\n        ret.set(salt, 1);\n        ret.set(data, 1 + ret[0]);\n        ret.toString = data.toString;\n        data = ret;\n    }\n\n    return data;\n}\n"],"names":["chr","String","fromCharCode","buffer2bin","buf","view8","apply","buffer2hex","bpe","BYTES_PER_ELEMENT","reduce","r","c","toString","padStart","buffer2str","asUtf8","isASCII","utf8Decode","undefined","err","str2buffer","str","hasMultibyte","utf8Encode","len","length","Uint8Array","charCodeAt","enc","btoa","start","copy","byteLength","buffer","byteOffset","hasMultibyteRE","isASCIIRE","m","exec","test","unescape","encodeURI","decodeURIComponent","escape","randomBytes","size","bits","ret","words","Uint32Array","ent","Date","now","Math","random","slice","CycleCrypt","key","salt","saltRounds","self","str2buf","min","_key","saltKey","Object","defineProperties","prototype","constructor","value","_","data","dataLength","klen","i","k","mixKey","keyByteSize","get","rounds","$i","ki","slen","s","max","si","b","set","cycleCrypt","cc"],"mappings":"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"}