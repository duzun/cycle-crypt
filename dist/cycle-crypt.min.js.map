{"version":3,"file":"cycle-crypt.min.js","sources":["../lib/string.js","../lib/randomBytes.js","../CycleCrypt.js","../cycle-crypt.js"],"sourcesContent":["/*requires Uint8Array*/\n/*globals escape, unescape, encodeURI, decodeURIComponent, btoa*/\n\nconst chr = String.fromCharCode;\n\nfunction ord(chr) {\n    return chr.charCodeAt(0);\n}\n\nexport function buffer2bin(buf) {\n    buf = view8(buf);\n    return chr.apply(String, buf);\n}\n\nexport function buffer2hex(buf) {\n    const bpe = buf.BYTES_PER_ELEMENT << 1;\n    return buf.reduce((r, c) => r += (c >>> 0).toString(16).padStart(bpe,'0'), '');\n}\n\nexport function buffer2str(buf, asUtf8) {\n    if(typeof buf == 'string') return buf;\n    buf = buffer2bin(buf);\n    if (asUtf8 !== false && !isASCII(buf)) {\n        if(asUtf8) {\n            buf = utf8Decode(buf);\n        } else if(asUtf8 == undefined) {\n            try {\n                buf = utf8Decode(buf);\n            } catch(err) {}\n        }\n    }\n    return buf;\n}\n\nexport function str2buffer(str, asUtf8) {\n    if(asUtf8 == undefined) {\n        // Some guessing\n        asUtf8 = hasMultibyte(str); // || !isASCII(str)\n    }\n    if (asUtf8) {\n        str = utf8Encode(str);\n    }\n    return new Uint8Array(str.split('').map(ord));\n}\n\n/**\n * This method is a replacement of Buffer.toString(enc)\n * for Browser, where Buffer is not available.\n *\n * @param   {String}  enc  'binary' | 'hex' | 'base64' | 'utf8' | undefined\n *\n * @return  {String}\n */\nexport function toString(enc) {\n    // The Node.js equivalent would be something like:\n    // if(typeof Buffer == 'function') {\n    //     if(enc === false) enc = 'binary';\n    //     if(enc === true) enc = 'utf8';\n    //     return Buffer.from(this.buffer, this.byteOffset, this.byteLength).toString(enc);\n    // }\n    switch(enc) {\n        case false:\n        case 'binary': return buffer2bin(this);\n        case 'hex': return buffer2hex(this);\n        case 'base64': return btoa(buffer2bin(this));\n        case 'utf8': enc = true; break;\n    }\n    return buffer2str(this, enc);\n}\n\nexport function view8(buf, start, len) {\n    // If buf is a Buffer, we still want to make it an Uint8Array\n    if(!start && !len && buf instanceof Uint8Array && !buf.copy) return buf;\n    start = start >>> 0;\n    if(len == undefined) len = buf.byteLength - start;\n    return new Uint8Array(buf.buffer, buf.byteOffset+start, len);\n}\n\nconst hasMultibyteRE = /([^\\x00-\\xFF]+)/;\nconst isASCIIRE = /^[\\x00-\\x7F]+$/;\n\nexport function hasMultibyte(str) {\n    let m = hasMultibyteRE.exec(str);\n    return m ? m[1] : false;\n}\n\nexport function isASCII(str) {\n    return isASCIIRE.test(str);\n}\n\nexport function utf8Encode(str) {\n    return unescape(encodeURI(str));\n}\n\nexport function utf8Decode(str) {\n    return decodeURIComponent(escape(str));\n}\n","/*requires Uint8Array, Uint32Array*/\n\nimport { toString } from \"./string\";\n\nexport default function randomBytes(size) {\n    const bits = -1 >>> 0;\n\n    let len = size & 3;\n    len = len ? size + 4 - len : size;\n    let ret = new Uint8Array(len);\n    const words = new Uint32Array(ret.buffer);\n    let ent = Date.now();\n\n    len >>= 2;\n    while (len--) {\n        words[len] =\n        ent ^= Math.random() * bits;\n    }\n\n    if(ret.length > size) {\n        ret = ret.slice(0, size);\n    }\n\n    ret.toString = toString;\n    return ret;\n}\n","/*requires Uint8Array, Uint32Array*/\n\nimport randomBytes from './lib/randomBytes';\nimport { str2buffer, view8, toString } from './lib/string';\n\n/**\n * Variable size symmetric key encryption algorithm.\n * The cipher-key is generated by cycling the input key with a variation of XorShift+ PRNG.\n * The bigger the key-size, the longer the period.\n *\n * @param   {String|ArrayBuffer}  key   The encryption key\n * @param   {String|ArrayBuffer|Boolean} salt\n *              If a string, use it as salt.\n *              If TRUE, generate salt.\n */\nexport default function CycleCrypt(key, salt = true) {\n    const self = this;\n\n    key = str2buf(key);\n    if (salt === true) {\n        salt = randomBytes(Math.min(256, key.byteLength << 1));\n    }\n    self.salt = salt;\n    self._key = key = saltKey(key, str2buf(salt));\n}\n\nObject.defineProperties(CycleCrypt.prototype, {\n    constructor: {\n        value: CycleCrypt,\n    },\n\n    /**\n     * Encrypt/decrypt the data and advance the internal state of the cipher-key.\n     *\n     * @param   {String|ArrayBuffer}  data  Data to encrypt\n     *\n     * @return  Uint8Array The encrypted/decrypted data\n     */\n    _: {\n        value: function _(data) {\n            data = str2buf(data);\n            const { dataLength } = data;\n            if (!dataLength) return data;\n\n            const key = this._key;\n            let klen = key.length;\n            let len = data.length;\n            for (let i = 0, k=0; i < len; ++i, ++k) {\n                // let k = i % klen;\n                if(k === klen) k = 0;\n                if (!k) mixKey(key);\n                data[i] ^= key[k];\n            }\n\n            data = view8(data, 0, dataLength);\n            data.toString = toString;\n            return data;\n        }\n    },\n\n    /**\n     * Get the number of bytes in the key\n     *\n     * @return  int\n     */\n    keyByteSize: {\n        get() {\n            return this._key.byteLength;\n        }\n    }\n});\n\n// Static methods:\nCycleCrypt.randomBytes = randomBytes; // Uint8Array\nCycleCrypt.toString = toString;\nCycleCrypt.str2buffer = str2buffer; // Uint8Array\nCycleCrypt.str2buf = str2buf; // Uint32Array\n// // CycleCrypt.buf2str = buf2str;\n\n/**\n * Use a variation of Xorshift+ to mix the key\n *\n * @param   Uint32Array $key List of int32 values representing the key\n * @param   int   $rounds Number of rounds to process the key\n *\n * @return  array A mixed key\n */\nfunction mixKey(key, rounds = 1) {\n    let len = key.length;\n    let k = len > 1 ? key[len - 1] : 0;\n    while (rounds-- > 0) {\n        for (let $i = len; $i--;) {\n            let ki = $i % len;\n            k = key[ki] + k;\n            k ^= k << 13; // 19\n            k ^= k >>> 17; // 15\n            k ^= k << 5; // 27\n            // k >>>= 0;\n            key[ki] = k;\n        }\n    }\n\n    return key;\n}\n\n/**\n * Use a variation of Xorshift+ to salt the key\n *\n * @param   Uint32Array $key\n * @param   Uint32Array $salt\n * @param   int   $rounds Number of rounds to mix the key\n *\n * @return  array A mixed key\n */\nfunction saltKey(key, salt, rounds = 1) {\n    let klen = key.length;\n    let slen = salt.length;\n    if (!slen) return key;\n\n    // make a copy to avoid altering the input salt\n    salt = salt.slice();\n\n    let k = klen > 1 ? key[klen - 1] : 0;\n    let s = slen > 1 ? salt[slen - 1] : 0;\n\n    while (rounds-- > 0) {\n        for (let i = Math.max(klen, slen); i--;) {\n            let ki = i % klen;\n            let si = i % slen;\n            k = key[ki] + k;\n            s = salt[si] + s;\n\n            s ^= s << 13; // 19\n            s ^= s >>> 7; // 25\n\n            k ^= k << 11; // 21\n            k ^= k >>> 8; // 24\n\n            // s >>>= 0;\n            k += s;\n            // k >>>= 0;\n\n            key[ki] = k;\n            salt[si] = s;\n        }\n    }\n\n    return key;\n}\n\nfunction str2buf(str) {\n    if (!str || typeof str.byteLength != 'number') {\n        str = str2buffer(str);\n    }\n    else {\n        str = view8(str);\n    }\n\n    // Make sure the new buffer has a multiple of 4 byteLength\n    const { byteLength } = str;\n    let b = byteLength & 3;\n    let i;\n    // if(b) {\n        b = byteLength + (b && (4 - b));\n        i = new Uint8Array(b);\n        i.set(str);\n    // }\n    // else {\n    //     b = byteLength;\n    //     i = str.slice();\n    // }\n\n    str = new Uint32Array(i.buffer, i.byteOffset, b >> 2);\n    str.dataLength = byteLength;\n\n    return str;\n}\n\n// Unused\n// function buf2str(buf) {\n//     return buffer2str(view8(buf));\n// }\n","// ---------------------------------------------------------------\n/*requires Uint8Array, Uint32Array*/\n// ---------------------------------------------------------------\nimport CycleCrypt from './CycleCrypt';\nimport { str2buffer, view8 } from './lib/string';\n\ncycleCrypt.CycleCrypt = CycleCrypt;\ncycleCrypt.randomBytes = CycleCrypt.randomBytes;\ncycleCrypt.str2buffer = CycleCrypt.str2buffer;\n\n// ---------------------------------------------------------------\n/**\n * Simple encryption using xor, a key and salt.\n *\n * @param   string|Uint8Array  $key   The encryption key\n * @param   string|Uint8Array  $data  Data to encrypt\n * @param   string|Uint8Array|bool $salt\n *              If a string, use it as salt.\n *              If TRUE, generate salt and prepend it to the encrypted data.\n *              If FALSE, get the salt from the data.\n *\n * @return  Uint8Array  The encrypted data. If $salt is TRUE, the generated salt is prepended to the result.\n */\nexport default function cycleCrypt(key, data, salt = true) {\n\n    // Read salt from input\n    if (salt === false) {\n        data = view8(typeof data == 'string' ? str2buffer(data) : data);\n        let i = data[0];\n        salt = data.slice(1, ++i);\n        data = data.slice(i);\n    }\n\n    const cc = new CycleCrypt(key, salt);\n    data = cc._(data);\n\n    // Add the generated salt to the output\n    if (salt === true) {\n        salt = cc.salt;\n        let ret = new Uint8Array(1 + salt.byteLength + data.byteLength);\n        ret[0] = salt.byteLength;\n        ret.set(salt, 1);\n        ret.set(data, 1 + ret[0]);\n        ret.toString = data.toString;\n        data = ret;\n    }\n\n    return data;\n}\n"],"names":["chr","String","fromCharCode","ord","charCodeAt","buffer2bin","buf","view8","apply","buffer2str","asUtf8","str","isASCIIRE","test","utf8Decode","undefined","err","str2buffer","m","hasMultibyteRE","exec","hasMultibyte","unescape","encodeURI","utf8Encode","Uint8Array","split","map","toString","enc","this","bpe","BYTES_PER_ELEMENT","reduce","r","c","padStart","btoa","start","len","copy","byteLength","buffer","byteOffset","decodeURIComponent","escape","randomBytes","size","ret","words","Uint32Array","ent","Date","now","Math","random","length","slice","CycleCrypt","key","salt","self","str2buf","min","_key","saltKey","mixKey","rounds","k","$i","ki","klen","slen","s","i","max","si","b","set","dataLength","cycleCrypt","data","cc","_","Object","defineProperties","prototype","constructor","value","keyByteSize","get"],"mappings":"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"}