{"version":3,"file":"cycle-crypt.min.js","sources":["../lib/string.js","../lib/randomBytes.js","../cycle-crypt.js"],"sourcesContent":["/*requires Uint8Array*/\n/*globals escape, unescape, encodeURI, decodeURIComponent, btoa*/\n\nconst chr = String.fromCharCode;\n\nfunction ord(chr) {\n    return chr.charCodeAt(0);\n}\n\nexport function buffer2bin(buf) {\n    if(buf.BYTES_PER_ELEMENT > 1) {\n        buf = new Uint8Array(buf.buffer);\n    }\n    return chr.apply(String, buf);\n}\n\nexport function buffer2hex(buf) {\n    return buf.reduce((r, c) => r += c.toString(16).padStart(2,'0'), '');\n}\n\nexport function buffer2str(buf, asUtf8) {\n    if(typeof buf == 'string') return buf;\n    buf = buffer2bin(buf);\n    if (asUtf8 !== false && !isASCII(buf)) {\n        if(asUtf8) {\n            buf = utf8Decode(buf);\n        } else if(asUtf8 == undefined) {\n            try {\n                buf = utf8Decode(buf);\n            } catch(err) {}\n        }\n    }\n    return buf;\n}\n\nexport function str2buffer(str, asUtf8) {\n    if(asUtf8 == undefined) {\n        // Some guessing\n        asUtf8 = hasMultibyte(str); // || !isASCII(str)\n    }\n    if (asUtf8) {\n        str = utf8Encode(str);\n    }\n    return new Uint8Array(str.split('').map(ord));\n}\n\n/**\n * This method is a replacement of Buffer.toString(enc)\n * for Browser, where Buffer is not available.\n *\n * @param   {String}  enc  'binary' | 'hex' | 'base64' | 'utf8' | undefined\n *\n * @return  {String}\n */\nexport function toString(enc) {\n    // The Node.js equivalent would be something like:\n    // if(typeof Buffer == 'function') {\n    //     if(enc === false) enc = 'binary';\n    //     if(enc === true) enc = 'utf8';\n    //     return Buffer.from(this.buffer).toString(enc);\n    // }\n    switch(enc) {\n        case false:\n        case 'binary': return buffer2bin(this);\n        case 'hex': return buffer2hex(this);\n        case 'base64': return btoa(buffer2bin(this));\n        case 'utf8': enc = true; break;\n    }\n    return buffer2str(this, enc);\n}\n\nconst hasMultibyteRE = /([^\\x00-\\xFF]+)/;\nconst isASCIIRE = /^[\\x00-\\x7F]+$/;\n\nexport function hasMultibyte(str) {\n    let m = hasMultibyteRE.exec(str);\n    return m ? m[1] : false;\n}\n\nexport function isASCII(str) {\n    return isASCIIRE.test(str);\n}\n\nexport function utf8Encode(str) {\n    return unescape(encodeURI(str));\n}\n\nexport function utf8Decode(str) {\n    return decodeURIComponent(escape(str));\n}\n","/*requires Uint8Array, Int32Array*/\n\nimport { toString } from \"./string\";\n\nexport default function randomBytes(size) {\n    const bits = -1 >>> 0;\n\n    let len = size & 3;\n    len = len ? size + 4 - len : size;\n    let ret = new Uint8Array(len);\n    const words = new Int32Array(ret.buffer);\n    let ent = Date.now();\n\n    len >>= 2;\n    while (len--) {\n        words[len] =\n        ent ^= Math.random() * bits;\n    }\n\n    if(ret.length > size) {\n        ret = ret.slice(0, size);\n    }\n\n    ret.toString = toString;\n    return ret;\n}\n","// ---------------------------------------------------------------\n/*requires Uint8Array, Int32Array*/\n// ---------------------------------------------------------------\nimport randomBytes from './lib/randomBytes';\nimport { str2buffer, buffer2str, toString } from './lib/string';\n\n// const INT32_MASK = -1 >>> 0;\ncycleCrypt.randomBytes = randomBytes;\ncycleCrypt.str2buffer = str2buffer;\n\n// ---------------------------------------------------------------\n/**\n * Simple encryption using xor, a key and salt.\n *\n * @param   string|Uint8Array  $key   The encryption key\n * @param   string|Uint8Array  $data  Data to encrypt\n * @param   string|Uint8Array|bool $salt\n *              If a string, use it as salt.\n *              If TRUE, generate salt and prepend it to the encrypted data.\n *              If FALSE, get the salt from the data.\n *\n * @return  Uint8Array  The encrypted data. If $salt is TRUE, the generated salt is prepended to the result.\n */\nexport default function cycleCrypt(key, data, salt = true) {\n    key = str2buf(key);\n    data = typeof data == 'string' ? str2buffer(data) : data;\n    let dataLen = data.byteLength;\n\n    let ret;\n    if (salt === true) {\n        ret = randomBytes(Math.min(256, key.byteLength * 2 + 1) + dataLen);\n        ret[0] = ret.length - 1 - dataLen;\n        salt = ret.slice(1, 1 + ret[0]);\n    }\n    else {\n        if (salt === false) {\n            let i = data[0];\n            salt = data.slice(1, ++i);\n            data = data.slice(i);\n            dataLen = data.byteLength;\n        }\n    }\n    key = cc32_salt_key(key, str2buf(salt));\n\n    if(dataLen & 3) {\n        data = str2buf(data);\n    }\n    else {\n        data = new Int32Array(data.buffer);\n    }\n\n    let len = key.length;\n    let i = 0;\n    data = data.map((b) => {\n        if(i == len) i = 0;\n        if(!i) cc32_mix_key(key);\n        return b ^ key[i++];\n    });\n\n    data = new Uint8Array(data.buffer);\n\n    if(data.byteLength > dataLen) {\n        data = data.slice(0, dataLen);\n    }\n\n    if (ret) {\n        ret.set(data, ret[0] + 1);\n    }\n    else {\n        ret = data;\n    }\n    ret.toString = toString;\n\n    return ret;\n}\n\n/**\n * Use a variation of Xorshift+ to mix the key\n *\n * @param   Int32Array $key List of int32 values representing the key\n * @param   int   $rounds Number of rounds to process the key\n *\n * @return  array A mixed key\n */\nfunction cc32_mix_key(key, rounds = 1) {\n    let len = key.length;\n    let k = len > 1 ? key[len - 1] : 0;\n    while (rounds-- > 0) {\n        for (let $i = len; $i--;) {\n            let ki = $i % len;\n            k = key[ki] + k;\n            k ^= k << 13; // 19\n            k ^= k >> 17; // 15\n            k ^= k << 5; // 27\n            // k &= INT32_MASK;\n            key[ki] = k;\n        }\n    }\n\n    return key;\n}\n\n/**\n * Use a variation of Xorshift+ to salt the key\n *\n * @param   Int32Array $key\n * @param   Int32Array $salt\n * @param   int   $rounds Number of rounds to mix the key\n *\n * @return  array A mixed key\n */\nfunction cc32_salt_key(key, salt, rounds = 1) {\n    let klen = key.length;\n    let slen = salt.length;\n    if (!slen) return key;\n\n    let k = klen > 1 ? key[klen - 1] : 0;\n    let s = slen > 1 ? salt[slen - 1] : 0;\n    while (rounds-- > 0) {\n        for (let i = Math.max(klen, slen); i--;) {\n            let ki = i % klen;\n            let si = i % slen;\n            k = key[ki] + k;\n            s = salt[si] + s;\n\n            s ^= s << 13; // 19\n            s ^= s >> 7; // 25\n\n            k ^= k << 11; // 21\n            k ^= k >> 8; // 24\n\n            k += s;\n\n            // k &= INT32_MASK;\n            // s &= INT32_MASK;\n\n            key[ki] = k;\n            salt[si] = s;\n        }\n    }\n\n    return key;\n}\n\nfunction str2buf(str) {\n    if (!str || typeof str.byteLength != 'number') {\n        str = str2buffer(str);\n    }\n\n    // Make sure the new buffer has a multiple of 4 byteLength\n    let b = str.byteLength & 3;\n    if(b) {\n        b = str.byteLength + 4 - b;\n        str = new Uint8Array(str.buffer);\n        let i = new Uint8Array(b);\n        i.set(str);\n        str = i;\n    }\n    return new Int32Array(str.buffer);\n}\n\n// Unused\n// function buf2str(buf) {\n//     return buffer2str(new Uint8Array(buf.buffer));\n// }\n"],"names":["chr","String","fromCharCode","ord","charCodeAt","buffer2bin","buf","BYTES_PER_ELEMENT","Uint8Array","buffer","apply","buffer2str","asUtf8","str","isASCIIRE","test","utf8Decode","undefined","err","str2buffer","m","hasMultibyteRE","exec","hasMultibyte","unescape","encodeURI","utf8Encode","split","map","toString","enc","this","reduce","r","c","padStart","btoa","decodeURIComponent","escape","randomBytes","size","len","ret","words","Int32Array","ent","Date","now","Math","random","length","slice","cycleCrypt","key","data","salt","str2buf","dataLen","byteLength","min","i","cc32_salt_key","b","cc32_mix_key","set","rounds","k","$i","ki","klen","slen","s","max","si"],"mappings":"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"}